/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2203 from the
 * contents of CDF.xs. Do not edit this file, edit CDF.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "CDF.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "cdflib/cdflib.h"

#ifndef PATCHLEVEL
#include <patchlevel.h>
#endif

#if defined(PATCHLEVEL) && (PATCHLEVEL < 5)
#define PL_sv_undef    sv_undef
#endif

static int
not_here(char *s)
{
    croak("%s not implemented on this architecture", s);
    return -1;
}

static double
constant(char *name, int arg)
{
    errno = 0;
    switch (*name) {
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}


#line 46 "CDF.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 98 "CDF.c"

XS(XS_Math__CDF_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "name, arg");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
	int	arg = (int)SvIV(ST(1));
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name, arg);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_pnorm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_pnorm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "z");
    {
	double	z = (double)SvNV(ST(0));
#line 51 "CDF.xs"
	int which=1, status;
	double p, q, mean=0.0, sd=1.0, bound;
#line 138 "CDF.c"
	SV *	RETVAL;
#line 54 "CDF.xs"
	ST(0) = sv_newmortal();
	(void)cdfnor(&which, &p, &q, &z, &mean, &sd, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)p );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 149 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_qnorm); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_qnorm)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	double	p = (double)SvNV(ST(0));
#line 67 "CDF.xs"
	int which=2, status;
	double z, q, mean=0.0, sd=1.0, bound;
#line 170 "CDF.c"
	SV *	RETVAL;
#line 70 "CDF.xs"
	q = 1.0 - p;
	ST(0) = sv_newmortal();
	(void)cdfnor(&which, &p, &q, &z, &mean, &sd, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)z );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 182 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_pt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_pt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "t, df, ncp = 0.0");
    {
	double	t = (double)SvNV(ST(0));
	double	df = (double)SvNV(ST(1));
	double	ncp;
#line 86 "CDF.xs"
	int which=1, status;
	double p, q, bound;
#line 205 "CDF.c"
	SV *	RETVAL;

	if (items < 3)
	    ncp = 0.0;
	else {
	    ncp = (double)SvNV(ST(2));
	}
#line 89 "CDF.xs"
	ST(0) = sv_newmortal();
	(void)cdftnc(&which, &p, &q, &t, &df, &ncp, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)p );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 222 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_qt); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_qt)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "p, df, ncp = 0.0");
    {
	double	p = (double)SvNV(ST(0));
	double	df = (double)SvNV(ST(1));
	double	ncp;
#line 104 "CDF.xs"
	int which=2, status;
	double t, q, bound;
#line 245 "CDF.c"
	SV *	RETVAL;

	if (items < 3)
	    ncp = 0.0;
	else {
	    ncp = (double)SvNV(ST(2));
	}
#line 107 "CDF.xs"
	q = 1.0 - p;
	ST(0) = sv_newmortal();
	(void)cdftnc(&which, &p, &q, &t, &df, &ncp, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)t );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 263 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_pbeta); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_pbeta)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "x, a, b");
    {
	double	x = (double)SvNV(ST(0));
	double	a = (double)SvNV(ST(1));
	double	b = (double)SvNV(ST(2));
#line 123 "CDF.xs"
	int which=1, status;
	double y, p, q, bound;
#line 286 "CDF.c"
	SV *	RETVAL;
#line 126 "CDF.xs"
	y = 1.0 - x;
	ST(0) = sv_newmortal();
	(void)cdfbet(&which, &p, &q, &x, &y, &a, &b, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)p );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 298 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_qbeta); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_qbeta)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "p, a, b");
    {
	double	p = (double)SvNV(ST(0));
	double	a = (double)SvNV(ST(1));
	double	b = (double)SvNV(ST(2));
#line 142 "CDF.xs"
	int which=2, status;
	double x, y, q, bound;
#line 321 "CDF.c"
	SV *	RETVAL;
#line 145 "CDF.xs"
	q = 1.0 - p;
	ST(0) = sv_newmortal();
	(void)cdfbet(&which, &p, &q, &x, &y, &a, &b, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)x );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 333 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_pchisq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_pchisq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "x, df, ncp = 0.0");
    {
	double	x = (double)SvNV(ST(0));
	double	df = (double)SvNV(ST(1));
	double	ncp;
#line 161 "CDF.xs"
	int which=1, status;
	double p, q, bound;
#line 356 "CDF.c"
	SV *	RETVAL;

	if (items < 3)
	    ncp = 0.0;
	else {
	    ncp = (double)SvNV(ST(2));
	}
#line 164 "CDF.xs"
	ST(0) = sv_newmortal();
	(void)cdfchn(&which, &p, &q, &x, &df, &ncp, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)p );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 373 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_qchisq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_qchisq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "p, df, ncp = 0.0");
    {
	double	p = (double)SvNV(ST(0));
	double	df = (double)SvNV(ST(1));
	double	ncp;
#line 179 "CDF.xs"
	int which=2, status;
	double x, q, bound;
#line 396 "CDF.c"
	SV *	RETVAL;

	if (items < 3)
	    ncp = 0.0;
	else {
	    ncp = (double)SvNV(ST(2));
	}
#line 182 "CDF.xs"
	q = 1.0 - p;
	ST(0) = sv_newmortal();
	(void)cdfchn(&which, &p, &q, &x, &df, &ncp, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)x );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 414 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_pf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_pf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "f, dfn, dfd, ncp = 0.0");
    {
	double	f = (double)SvNV(ST(0));
	double	dfn = (double)SvNV(ST(1));
	double	dfd = (double)SvNV(ST(2));
	double	ncp;
#line 199 "CDF.xs"
	int which=1, status;
	double p, q, bound;
#line 438 "CDF.c"
	SV *	RETVAL;

	if (items < 4)
	    ncp = 0.0;
	else {
	    ncp = (double)SvNV(ST(3));
	}
#line 202 "CDF.xs"
	ST(0) = sv_newmortal();
	(void)cdffnc(&which, &p, &q, &f, &dfn, &dfd, &ncp, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)p );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 455 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_qf); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_qf)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "p, dfn, dfd, ncp = 0.0");
    {
	double	p = (double)SvNV(ST(0));
	double	dfn = (double)SvNV(ST(1));
	double	dfd = (double)SvNV(ST(2));
	double	ncp;
#line 218 "CDF.xs"
	int which=2, status;
	double f, q, bound;
#line 479 "CDF.c"
	SV *	RETVAL;

	if (items < 4)
	    ncp = 0.0;
	else {
	    ncp = (double)SvNV(ST(3));
	}
#line 221 "CDF.xs"
	q = 1.0 - p;
	ST(0) = sv_newmortal();
	(void)cdffnc(&which, &p, &q, &f, &dfn, &dfd, &ncp, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)f );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 497 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_pgamma); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_pgamma)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "x, shape, scale");
    {
	double	x = (double)SvNV(ST(0));
	double	shape = (double)SvNV(ST(1));
	double	scale = (double)SvNV(ST(2));
#line 237 "CDF.xs"
	int which=1, status;
	double p, q, bound;
#line 520 "CDF.c"
	SV *	RETVAL;
#line 240 "CDF.xs"
	ST(0) = sv_newmortal();
	(void)cdfgam(&which, &p, &q, &x, &shape, &scale, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)p );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 531 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_qgamma); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_qgamma)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "p, shape, scale");
    {
	double	p = (double)SvNV(ST(0));
	double	shape = (double)SvNV(ST(1));
	double	scale = (double)SvNV(ST(2));
#line 255 "CDF.xs"
	int which=2, status;
	double x, q, bound;
#line 554 "CDF.c"
	SV *	RETVAL;
#line 258 "CDF.xs"
	q = 1.0 - p;
	ST(0) = sv_newmortal();
	(void)cdfgam(&which, &p, &q, &x, &shape, &scale, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)x );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 566 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_ppois); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_ppois)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "x, lambda");
    {
	double	x = (double)SvNV(ST(0));
	double	lambda = (double)SvNV(ST(1));
#line 273 "CDF.xs"
	int which=1, status;
	double p, q, bound;
#line 588 "CDF.c"
	SV *	RETVAL;
#line 276 "CDF.xs"
	ST(0) = sv_newmortal();
	(void)cdfpoi(&which, &p, &q, &x, &lambda, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)p );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 599 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_qpois); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_qpois)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "p, lambda");
    {
	double	p = (double)SvNV(ST(0));
	double	lambda = (double)SvNV(ST(1));
#line 290 "CDF.xs"
	int which=2, status;
	double x, q, bound;
#line 621 "CDF.c"
	SV *	RETVAL;
#line 293 "CDF.xs"
	q = 1.0 - p;
	ST(0) = sv_newmortal();
	(void)cdfpoi(&which, &p, &q, &x, &lambda, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)x );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 633 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_pbinom); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_pbinom)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "x, n, pr");
    {
	double	x = (double)SvNV(ST(0));
	double	n = (double)SvNV(ST(1));
	double	pr = (double)SvNV(ST(2));
#line 309 "CDF.xs"
	int which=1, status;
	double p, q, ompr, bound;
#line 656 "CDF.c"
	SV *	RETVAL;
#line 312 "CDF.xs"
	ompr = 1.0 - pr;
	ST(0) = sv_newmortal();
	(void)cdfbin(&which, &p, &q, &x, &n, &pr, &ompr, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)p );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 668 "CDF.c"
    }
    XSRETURN(1);
}


XS(XS_Math__CDF_pnbinom); /* prototype to pass -Wmissing-prototypes */
XS(XS_Math__CDF_pnbinom)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "x, n, pr");
    {
	double	x = (double)SvNV(ST(0));
	double	n = (double)SvNV(ST(1));
	double	pr = (double)SvNV(ST(2));
#line 328 "CDF.xs"
	int which=1, status;
	double ompr, p, q, bound;
#line 691 "CDF.c"
	SV *	RETVAL;
#line 331 "CDF.xs"
	ompr = 1.0 - pr;
	ST(0) = sv_newmortal();
	(void)cdfnbn(&which, &p, &q, &x, &n, &pr, &ompr, &status, &bound);
	if(status == 0) {
		sv_setnv( ST(0), (double)p );
	}
	else{
		ST(0) = &PL_sv_undef;
	}
#line 703 "CDF.c"
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Math__CDF); /* prototype to pass -Wmissing-prototypes */
XS(boot_Math__CDF)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("Math::CDF::constant", XS_Math__CDF_constant, file, "$$");
        (void)newXSproto_portable("Math::CDF::pnorm", XS_Math__CDF_pnorm, file, "$");
        (void)newXSproto_portable("Math::CDF::qnorm", XS_Math__CDF_qnorm, file, "$");
        (void)newXSproto_portable("Math::CDF::pt", XS_Math__CDF_pt, file, "$$;$");
        (void)newXSproto_portable("Math::CDF::qt", XS_Math__CDF_qt, file, "$$;$");
        (void)newXSproto_portable("Math::CDF::pbeta", XS_Math__CDF_pbeta, file, "$$$");
        (void)newXSproto_portable("Math::CDF::qbeta", XS_Math__CDF_qbeta, file, "$$$");
        (void)newXSproto_portable("Math::CDF::pchisq", XS_Math__CDF_pchisq, file, "$$;$");
        (void)newXSproto_portable("Math::CDF::qchisq", XS_Math__CDF_qchisq, file, "$$;$");
        (void)newXSproto_portable("Math::CDF::pf", XS_Math__CDF_pf, file, "$$$;$");
        (void)newXSproto_portable("Math::CDF::qf", XS_Math__CDF_qf, file, "$$$;$");
        (void)newXSproto_portable("Math::CDF::pgamma", XS_Math__CDF_pgamma, file, "$$$");
        (void)newXSproto_portable("Math::CDF::qgamma", XS_Math__CDF_qgamma, file, "$$$");
        (void)newXSproto_portable("Math::CDF::ppois", XS_Math__CDF_ppois, file, "$$");
        (void)newXSproto_portable("Math::CDF::qpois", XS_Math__CDF_qpois, file, "$$");
        (void)newXSproto_portable("Math::CDF::pbinom", XS_Math__CDF_pbinom, file, "$$$");
        (void)newXSproto_portable("Math::CDF::pnbinom", XS_Math__CDF_pnbinom, file, "$$$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

